Managing multiple chat channels in my app was achieved by assigning each room a unique identifier and tagging every message with its corresponding room ID. In the client code, I filtered messages so only those matching the current room were displayed, using logic in chat and the useChat hook. The UI features a dynamic channel selector, with real-time updates, allowing users to easily switch rooms and see activity.

Implementing user presence across channels was challenging. The code in chatService.ts emits typing events, and the client listens for these events to update presence indicators. I had to ensure that typing events were only sent and received within the active channel, and that switching rooms cleared stale indicators. Handling edge cases, such as users quickly switching rooms or using multiple devices, required careful event management and debouncing in both the client and server logic.

Offline message handling is supported by local storage (SQLite) in the chatDatabaseService. Users can view previous messages and compose new ones while offline, and outgoing messages are queued locally and sent when connectivity returns. This approach covers basic offline scenarios, but lacks advanced features found in apps like Slack or Discord, such as rich notifications, message retries, and conflict resolution. With more time, I would implement a more robust offline queue and sync logic to ensure reliable delivery and better user feedback.

If I had more time, I would improve the user experience by refining onboarding, allowing users to set their username and preferences more intuitively. I’d add support for avatars and richer presence indicators, and enhance channel management to allow users to create, rename, and archive rooms. Accessibility and responsiveness would be a priority, ensuring the app works well on all devices and screen sizes. I’d also polish the notification system so users are alerted to new messages and mentions even when the app is in the background.

Consistent real-time behavior across platforms was ensured by using a Socket.IO client for both web and mobile. Unique user IDs are generated per device/session and preferences are stored securely, avoiding conflicts and ensuring accurate activity tracking. Message deduplication and error handling in the client keep the app stable even under heavy load or intermittent connectivity.

Building this multi-channel, cross-platform chat app deepened my understanding of real-time systems, state management, and user experience design, and gave me a strong foundation for future improvements.
